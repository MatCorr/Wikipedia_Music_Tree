########################################################################################################################
# This module is part of the Wikipedia Music Tree Project.                                                             #
#                                                                                                                      #
# This module should be run once the matrix built by the build_matrix_from_raw_data.py script has been created.        #
#                                                                                                                      #
# Based on that matrix, which stores the mentions to other artists contained in the Wikipedia articles of musical      #
# artists, this module will create a CSV file that can be fed into Gephi for the generation of a graph. Starting from  #
# a specified root node representing an artist (say, The Beatles), this graph will show the mentions that Wikipedia    #
# article contains to other artists; the mentions the Wikipedia articles of these other artists make to other artists  #
# and so forth.                                                                                                        #
#                                                                                                                      #
# There are three parameters that need to be informed:                                                                 #
# 1- root_node - The name of the artist that will be the root node.                                                    #
#                                                                                                                      #
# 2- depth - If equal to 1, the generated CSV will only include the root artist and artists mentioned in its article.  #
# If equal to 2, the generated CSV will consider the root artist, the artists mentioned in its article, and the        #
# artists mentioned in the articles of those artists. And so forth. In other words, the depth parameter determines     #
# how many steps away an artist must be from the root artist in order for it to be included in the CSV.                #
#                                                                                                                      #
# 3- relative_path_matrix - Relative path to the matrix generated by the build_matrix_from_raw_data.py script.         #
#                                                                                                                      #
# 4- relative_path_graph_csv - Relative path where the resulting CSV will be saved.                                    #
#                                                                                                                      #
# The generated CSV will be organized in a way that makes it ready to be processed by the Gephi software, which will   #
# allow the resulting graph to be visualized properly. The columns it will contain are:                                #
#                                                                                                                      #
# Source (artist), Target (artist that is mentioned by Source's Wikipedia article), Weight (number of times Target is  #
# mentioned in Source's article).                                                                                      #
#                                                                                                                      #
# Note that root_node needs to have the name of the artist exactly as it is on the title of its Wikipedia article. For #
# example, the title of the article of The Beatles is simply "The Beatles". But many artists, like The Replacements,   #
# have article titles that include the disambiguation term; in that case, root_node needs to include that part,        #
# so root_node should be "The Replacements (band)".                                                                    #
########################################################################################################################

########################################################################################################################
####################################################### Imports ########################################################
########################################################################################################################

from absl import  app, flags
from absl.flags import FLAGS
import numpy as np
import os
import pandas as pd

########################################################################################################################
##################################################### Parameters #######################################################
########################################################################################################################

flags.DEFINE_string('root_node', 'Neil Young', 'Musical artist that will be the root of the graph.')
flags.DEFINE_integer('depth', 1, 'Defines how distant an artist must be from the root in order for them to appear in the graph. Must be 1 or more.')
flags.DEFINE_string('relative_path_matrix', '../data/resulting_mention_matrix/matrix.csv', 'Relative path to the input matrix.')
flags.DEFINE_string('relative_path_graph_csv', '../data/graph_data/', 'Relative path to the input matrix.')

########################################################################################################################
######################################################## Main ##########################################################
########################################################################################################################

def main(_argv):
    """
    This function represents the module's main flow of execution. Here, the matrix generated by the build_matrix_from_raw_data.py
    script will be read and the parameters root_node and depth will be used to build a CSV containing multiple artists and the
    mentions to other artists contained in each one's Wikipedia article.
    """

    # Obtaining the specified parameters.
    root_node = FLAGS.root_node
    depth = FLAGS.depth
    relative_path_matrix = FLAGS.relative_path_matrix
    relative_path_graph_csv  = FLAGS.relative_path_graph_csv

    # Converting relative paths to absolute ones.
    file_dir = os.path.dirname(os.path.abspath(__file__))
    path_matrix = os.path.join(file_dir, relative_path_matrix)
    path_graph_csv = os.path.join(file_dir, relative_path_graph_csv)

    # Creating an empty data frame that will be filled up throughout this code.
    df_csv = pd.DataFrame(columns=['Source', 'Target', 'Weight'])

    # Reading the matrix generated by the build_matrix_from_raw_data.py script. It has all artists whose Wikipedia articles
    # we are using and the mentions to other artists contained in those articles.
    df_matrix = pd.read_csv(path_matrix, sep=',', encoding='UTF-8')

    # Filling up the NaN values with empty strings. Some artists may have articles that do not mention any other artists, which makes column
    # MENTIONED_ARTISTS be a potential spot for NaN values. Since values of that kind would produce an error in a search we are going to do
    # down the line, here they are replaced with empty spaces.
    df_matrix = df_matrix.fillna('')
    
    # Here, we get the list of all artists contained in the matrix.
    artists_list = list(df_matrix['ARTIST_NAME'])

    # We will use that list as the index for the matrix. It will make finding artists we want much easier and faster.
    df_matrix.index = artists_list

    # Here, we create two sets that will be essential to our processing. The first will contain what we are calling "selected artists",
    # which are the artists whose articles will be considered when building the resulting CSV. The second list will contain what we are
    # calling "mentioned_artists", who are the artists mentioned in the articles of the "selected artists". These lists are sets because
    # we do not want repetitions to occur. If an artist is already in the list, they do not have to be added again.
    selected_artists_list = set()
    related_artists_list = set()

    # The first selected artist is, of course, the one specified by the user as the root of the graph.
    selected_artists_list.add(root_node)
  
    # Now we start a loop limited by the specified depth. Beginning from the artist specified as the root, we will identify who are the "selected
    # artists" (that is, those that will be shown in the graph).
    for i in range(0, depth):

        # Obtaining the artists that are related to the selected artists. On the first iteration of the loop, related_artists_list will be those
        # mentioned in the Wikipedia article of the root artist; in other words, those who are in the MENTIONED_ARTISTS column of the matrix for
        # the record of said artist. Note that, given the MENTIONED_ARTISTS column is itself a list of artists separated by ";", the
        # related_artists_list is a list of lists. 
        related_artists_list = df_matrix.loc[selected_artists_list, 'MENTIONED_ARTISTS']

        # This inner loop has two tasks: formatting the related_artists_list and adding those formatted artists to the selected_artists_list.
        # That way, if there is another iteration due to the value of depth, the related_artists_list of this round will be part of the selected_artists_list
        # of the next.
        for related_artists in related_artists_list:
            
            # Each item in the related_artists_list is split by ";", which is the separator of the MENTIONED_ARTISTS column.. That way, formatted_related_artists 
            # will be a list of ARTIST_NAME:NUMBER_OF_MENTIONS.
            formatted_related_artists = str(related_artists).split(";")

            # Here, our interest is not in the NUMBER_OF_MENTIONS that are made to that artist; that's for another time. We just want its
            # name. So we split every ARTIST_NAME:NUMBER_OF_MENTIONS tuple by ":", obtaining only the ARTIST_NAME part and adding it to the
            # selected_artists_list.
            selected_artists_list = selected_artists_list.union(set([related_artist.rsplit(":")[0] for related_artist in formatted_related_artists]))

        # We remove potential empty strings from the selected_artists_list. Empty strings can get in here because some artists simply do not have
        # MENTIONED_ARTISTS in their Wikipedia articles.
        filter_object = filter(None, selected_artists_list)
        selected_artists_list = set(filter_object)


    # Removing empty strings from selected_artists_list. This needs to be done because some artists simply don't have any artists mentioned in their Wikipedia
    # article. After doing so, we turn our set into a list. This will make further processing easier.
    selected_artists_list = [selected_artist for selected_artist in selected_artists_list if selected_artist]
    selected_artists_list = list(selected_artists_list)

    # This is the final step of our processing. We will use the selected_artists_list created in the previous loop to build our resulting CSV.
    # We start by iterating through the selected artists one by one.
    for selected_artist in selected_artists_list:

        # This is just an extra check to avoid errors in the processing. One of the first steps we performed was using the variable
        # artists_list as the index for df_matrix. Since we will use that index now to look for the artist we want, here we make sure that
        # the artist we are looking for is in the index.
        if (selected_artist in artists_list):

            # For the artist we are working with, we select the artists mentioned in its Wikipedia article; that is, those listed in the
            # MENTIONED_ARTISTS column.
            related_artists_list = df_matrix.loc[selected_artist, 'MENTIONED_ARTISTS']

            # Again, MENTIONED_ARTISTS is a string/list of ARTIST_NAME:NUMBER_OF_MENTIONS tuples separated by ";". Here,
            # we turn that string into an actual list by splitting via ";".
            related_artists_list = str(related_artists_list).split(";")

            # Now we iterate over the related artists.
            for related_artist in related_artists_list:
                
                # Each related_artist is a ARTIST_NAME:NUMBER_OF_MENTIONS tuple. We split by ":" in order to obtain just the name
                # and check if that artist should appear on the graph based on the specified depth. That check is done via the selected_artists_list
                # built in the previous loop. If the artist is in the list, he will be in the CSV and, therefore, in the graph.
                if (related_artist.rsplit(":")[0] in selected_artists_list):

                    # Here we create a new record. Source will be the selected_artist. Target will be the related_artist. And Weight will be the
                    # number of times Target is mentioned in Source's Wikipedia article.
                    new_csv_record = pd.DataFrame(np.array([[selected_artist, related_artist.rsplit(":")[0], related_artist.rsplit(":")[1]]]), columns=['Source', 'Target', 'Weight'])

                    # Adding line to the dataframe that will be turned into a CSV later on.
                    df_csv = df_csv.append(new_csv_record)

    # After building the CSV, we save it to the specified folder.
    # The name of the CSV will be root_node-fromRoot-depthX.csv
    df_csv.to_csv(os.path.join(path_graph_csv, root_node.replace(" ", "") + "-fromRoot-" + "depth" + str(depth) + ".csv"), sep=',', index=False, encoding='UTF-8')
    
if __name__ == '__main__':
    try:
        app.run(main)
    except SystemExit:
        pass